---
title: Burp suite插件使用方法集合
date: 2024-10-15 21:00:00 +0800

categories: [Burp suite,Extensions]
tags: [Burp suite]


pin: false
math: true
mermaid: true
image:
  path: /imgs/Article_cover/20241015_211100.png
---

## 一、HaE

项目地址：<https://github.com/gh0stkey/HaE>

作者视频讲解：[从0到1认识实战攻防工具HaE_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Xy421B77g/?spm_id_from=333.788.recommend_more_video.-1&vd_source=35e0e710beb8b117ea7983818e72a436)

### 1、介绍

HaE是基于 BurpSuite JavaAPl 开发的请求高亮标记与信息提取的辅助型框架式插件，该插件可以通过自定义正则的方式匹配响应报文或请求报文，可以自行决定

符合该自定义正则匹配的相应请求是否需要高亮标记、信息提取。

### 2、优点

在流量多而杂的场景下，不免会浪费很多时间去看请求，借助HaE插件可以**有效的减少测试的时间**，以高亮的方式标记出你所需要的请求或响应，高效的进行漏洞

挖掘和测试。

### 3、应用场景

#### ①信息收集

内网API接口、网站指纹、页面注释...

#### ②敏感信息

手机号、身份证号码、邮箱、银行卡号、用户账号密码、OSS存储密钥...

#### ③漏洞发现

命令/代码执行、拒绝服务、SSRF、URL跳转、反序列化...

### 4、规则

#### (1)Fingerprint

**指纹信息**

#### (2)Maybe Vulnerability

**脆弱性**

#### ①DoS Paramters

拒绝服务参数规则，匹配请求中的size、page、num参数

**实战应用：**

![image-20241014133543423](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241014133543423.png)

修改参数pageSize和pageNum为一个较大的值，页面会返回大量数据。

**注意：**谨慎测试，容易影响正常业务

#### ②Debug Logic Parameters

逻辑调试函数

#### ③Java Deserialization

Java反序列化

#### (3)Basic Information

**基本信息**

Email

Chinese IDCard

Chinese Mobile Number

Internal IP Address

MAC Address

#### (4)Sensitive Information

**敏感信息**

#### ①AccessKey

AccessKey包括AccessKeyID和AcessKeySecret两部分，AccessKeyID用于标识用户，AcessKeySecret用于验证用户的密钥，主要用于程序方式调用云服务API。

#### ②OSS

对象存储

**解释：**

对象存储服务（Object Storage Service，OSS）是一种海量、安全、低成本、高可靠的云存储服务，适合存放任意类型的文件。容量和处理能力弹性扩展，多种存储类型供选择，全面优化存储成本。

**例子：**

当测试某个上传点时，获取到一个HTML表单：

![image-20241014172515289](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241014172515289.png)

请求的主机名xxxx.aliyuncs.com和表单的OSSAccessKeyId参数，基本可以确认系统使用 OSS 作为上传文件存储，即使上传恶意脚本文件也无法成功解析。

破局办法：

通过查阅相关文件，我们可以知道**使用表单上传文件到 OSS的技术方案里，有三种实现方式：**

```
OSS产品文档：https://help.aliyun.com/document_detail/31923.html
```

1. 在客户端通过JavaScript代码完成签名，然后通过表单直传数据到OSS。
2. 在服务端完成签名，然后通过表单直传数据到OSS。
3. 在服务端完成签名，并且服务端设置了上传后回调，然后通过表单直传数据到OSS。OSS回调完成后，再将应用服务器响应结果返回给客户端。

当采用JavaScript客户端直接签名时，**AccessKeyID和AcessKeySecret会暴露在前端页面**，存在严重的安全隐患。

通过翻找js文件，可发现AccessKey就写在js文件里面。

![image-20241014172716741](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241014172716741.png)

**参考文章：**[由OSS AccessKey泄露引发的思考 - Bypass - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiaozi/p/11767841.html)

#### (5)其他

#### ①Create Script规则

介绍：匹配响应报文中createElement（常见script标签）的内容

![image-20241014133130636](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241014133130636.png)



例子：

![image-20241014130817837](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241014130817837.png)

JS文件/JS路径 的拼接

访问xxx/static/js/chunk-079f2fa8.e2fd14e5.js



#### ②Linkfinder

匹配响应报文中的链接、请求路径等信息

**实战应用：**

把链接/路径可以跑一遍

## 二、BurpCrypto

### 1、介绍

**AES/DES/RSA加密：**

①对称加密算法：

AES和DES加密都属于对称加密算法，既加解密使用同一套密钥的加密算法，同时也是目前前端加密中较为常见的加密算法，目前插件支持的AES加密算法有：

- AES/CBC/PKCS5Padding
- AES/CBC/NoPadding
- AES/CBC/ZeroPadding
- AES/ECB/PKCS5Padding
- AES/ECB/NoPadding
- AES/ECB/ZeroPadding
- AES/OFB/PKCS5Padding
- AES/OFB/NoPadding
- AES/OFB/ZeroPadding
- AES/CFB/PKCS5Padding
- AES/CFB/NoPadding
- AES/CFB/ZeroPadding
- AES/CTR/PKCS5Padding
- AES/CTR/NoPadding
- AES/CTR/ZeroPadding

DES加密算法有：

- DES/CBC/PKCS5Padding
- DES/CBC/ZeroPadding
- DES/CBC/NoPadding
- DES/ECB/PKCS5Padding
- DES/ECB/ZeroPadding
- DES/ECB/NoPadding
- DES/OFB/PKCS5Padding
- DES/OFB/ZeroPadding
- DES/OFB/NoPadding
- DES/CFB/PKCS5Padding
- DES/CFB/ZeroPadding
- DES/CFB/NoPadding
- DESede/CBC/PKCS5Padding
- DESede/CBC/ZeroPadding
- DESede/CBC/NoPadding
- DESede/ECB/PKCS5Padding
- DESede/ECB/ZeroPadding
- DESede/ECB/NoPadding
- DESede/OFB/PKCS5Padding
- DESede/OFB/ZeroPadding
- DESede/OFB/NoPadding
- DESede/CFB/PKCS5Padding
- DESede/CFB/ZeroPadding
- DESede/CFB/NoPadding
- strEnc

> 在前端JS中常常会使用PKCS7Padding，在本模块中可使用PKCS5Padding代替，不影响使用。
>
> DES加密中的strEnc算法是取自作者Guapo的一种3DES的模块，在少数系统中被使用，此处为了方便使用也引入了进来。

②非对称加密算法

RSA算法则属于非对称加密算法，密钥分为公钥与私钥，**暂时仅支持公钥加密，RSA加密支持**两种公钥格式的输入，分别为

- X509
- ModulusAndExponent

X509密钥格式表现为一串由Base64编码后的字符串，常常以`MIG`开头。ModulusAndExponent(模数，指数)则表现为两个HEX编码的参数，Modulus是模数，常常较长，Exponent是指数，常常只有6位，以下为密钥示例：

```
X509: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCC0hrRIjb3noDWNtbDpANbjt5Iwu2NFeDwU16Ec87ToqeoIm2KI+cOs81JP9aTDk/jkAlU97mN8wZkEMDr5utAZtMVht7GLX33Wx9XjqxUsDfsGkqNL8dXJklWDu9Zh80Ui2Ug+340d5dZtKtd+nv09QZqGjdnSp9PTfFDBY133QIDAQAB
ModulusAndExponent:
  Modulus: A1E4D93618B8B240530853E87738403851E15BBB77421F9B2377FB0B4F1C6FC235EAEC92EA25BB76AC221DCE90173A2E232FE1511909C76B15251D4059B288E709C1EF86BCF692757AAD736882DD1E98BEDFED9311A3C22C40657C9A52880BDC4B9E539041D44D52CB26AD13AB086F7DC294D144D6633A62EF91CA1775EB9A09
  Exponent: 010001
```

### 2、使用方法

![image](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image.png)加密

### 加密

#### （1）Quick Crypto（全局调用）

当在`BurpCryto`有定义某种加密方式时，在`Proxy`、`Intruder`、`Repeater`模块选中要加密的部分，右击`拓展`找到`Quick Crypto`即可

### 解密

#### （1）Intruder模块：

①先判断相关接口的加密算法，这里以以AES的CBC模式为例

②在页面添加密钥（Key）和参数（IV）后点击【Add processor】，输入名称后点击【确定】，显示“Apply processor success!”标识添加成功

![image-20241014194509304](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241014194509304.png)

③在【Intruder】-->【paylaod】-->【Payload处理】-->【添加】-->【调用Burp拓展】然后选择刚刚命名的加密方式

![image-20241014195453836](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241014195453836.png)

#### （2）Exec JS（自定义JS加密代码还原）

①找到加密函数后把整个代码复制粘贴过来，在下方的【Js Method Name】中填写入口函数（以该加密函数为例，该加密函数需实例化`md5Code`类后调用其`getValue`函数，而本插件仅支持单参数的函数调用，于是需要编写一个中间函数`calc`，将核心加密函数直接暴露出来供插件调用。）

![image-20241014211812098](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241014211812098.png)

此处填写需要让插件调用的加密函数的函数名称，在这个例子中就是`calc`函数。

![image-20241014211852289](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241014211852289.png)

（或者知道怎么加密之后，在此处编写加密代码，这里右击有快捷键【Append Simple Function】）

然后点击【Add processor】取个名字然后保存

同上面常规使用方法在Intruder模块使用。

**原理：**

把待处理的内容传递给入口函数的第一个参数，然后返回处理后的结果。

#### （3）直接解密单个字段（查询原文）

由于部分算法产生的结果有不可逆性（哈希、自定义JS等），插件产生的所有结果被保存在本地的K/V数据库中，可以通过下图方法获取`Get PlainText`功能获取原始密文

e.g.：RSA公钥加密后通过密文查询原始明文

![image-20241014202117193](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241014202117193.png)

![image-20241014202126115](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241014202126115.png)

### 3、数据库清理

本插件中使用了本地持久化的K/V数据库（leveldb），由于在爆破等使用场景时会写入大量的数据，长时间使用后将有可能会拖慢插件的响应速度。为了保证用户爆破数据不会丢失，插件将不会主动清理数据，所以建议用户确定不再需要陈旧的数据的时候，及时清理数据库。

K/V数据库清理较为简单，首先需将BurpSuite完全退出，然后手动删除BurpSuite的jar文件同目录下的`BurpCrypto.ldb`文件夹即可

## 三、jsEncrypter

项目地址：<https://github.com/c0ny1/jsEncrypter/releases>

### 1、介绍

前端加密Fuzz插件

本插件使用`phantomjs`启动前端加密函数对数据进行加密，方便对加密数据输入点进行fuzz，比如可以使用于前端加密传输爆破等场景。

### 2、使用方法

提供了七种加密算法

![image-20241015194105898](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015194105898.png)

（1）以md5为例

把webapp/js/md5.js复制

在目录下创建md5.js文件，写入加密代码

![image-20241015193151065](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015193151065.png)

（2）在phantomjs_server.js文件中引入文件，并调用md5.js中的主函数

![image-20241015193056264](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015193056264.png)

（3）启动

~~~
phantomjs.exe phantomjs_server.js
~~~

（4）`connect` --->`Test`，成功把字符加密

![image-20241015194611762](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015194611762.png)

（5）在Intruder模块加载插件，然后测试会在cmd中显示

![image-20241015194800849](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015194800849.png)

![image-20241015194821333](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015194821333.png)

（6）目录下会生成日志文件jsEncrypter.log，可以根据密文搜索对应的明文

![image-20241015194843506](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015194843506.png)

## 四、CaA

项目地址：<https://github.com/gh0stkey/CaA>

作者视频讲解：https://www.bilibili.com/video/BV1F8WzeFEu5/?spm_id_from=333.999.0.0&vd_source=35e0e710beb8b117ea7983818e72a436

### 1、介绍

主要用于分析、拆解HTTP协议报文，提取HTTP协议报文中的参数、路径、文件、参数值等信息，并统计出现的频次，帮助用户构建出具有实战应用价值的Fuzzing字典。除此之外CaA可以生成各类HTTP请求提供给BurpSuite Intruder用于Fuzzing工作。

**CaA**的设计思想来源于**Web Fuzzing技术**，皆在帮助用户发现隐藏的漏洞面，通过对信息的收集分析整理，让用户真正意义上的实现**数据挖掘**。

### 2、使用方法

### （1）人工手动

**在Repeater模块**

①可以提取响应包中的信息字段：

![image-20241015173526634](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015173526634.png)

![image-20241015173131219](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015173131219.png)

②在`Current`下，右键`Copy Payload` --->`Raw`使用当前响应包中的参数进行测试：

![image-20241015173055572](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015173055572.png)

![image-20241015173650085](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015173650085.png)

返回包中没有变化

③在`All`下，用127.0.0.1路径下的所有参数进行测试

![image-20241015173926072](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015173926072.png)

可以看到返回包发生了改变，多了WJPPqe，这里可能存在JSONP和反射XSS漏洞

![image-20241015174010958](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015174010958.png)

### （2）自动

①右击，`Send to Payload GGenerator`，增删改查参数，然后发送给Payload生成器，然后把数据包发送到Intruder模块

![image-20241015174258804](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015174258804.png)

![image-20241015174557655](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015174557655.png)

②在Intruder模块，将整个数据包作为参数，然后在`Payload`进行如下图配置

![image-20241015174840647](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015174840647.png)

![image-20241015174807652](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015174807652.png)

这里是各个参数的自由组合（两个、三个....），还有GET、POST请求方式，还有XML、

JSON、上传表单形式的，然后筛选有问题的数据包即可

![image-20241015175024376](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015175024376.png)

![image-20241015175311270](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015175311270.png)

![image-20241015175407912](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015175407912.png)

![image-20241015175416840](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015175416840.png)

![image-20241015175232371](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015175232371.png)

## 五、BurpJSLinkFinder

项目地址：<https://github.com/InitRoot/BurpJSLinkFinder?tab=readme-ov-file>

### 1、介绍

用于**被动扫描 J**S 文件的端点链接

### 2、使用方法

（1）配置要爬取的主机/IP（输入关键字就行）

![image-20241015205147143](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015205147143.png)

（2）在`仪表盘`的设置中，配置`URL范围`

![image-20241015205237704](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015205237704.png)

![image-20241015205307361](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015205307361.png)

（3）访问相应的网站爬取到js文件

![image-20241015205837559](https://raw.githubusercontent.com/Leaderchen007/Leaderchen007.github.io/refs/heads/master/imgs/1/image-20241015205837559.png)

## 六、BurpAPIFinder

项目地址：<https://github.com/shuanx/BurpAPIFinder>

### 1、介绍

我们可以：
1、发现通过某接口可以进行未授权/越权获取到所有的账号密码、私钥、凭证
2、发现通过某接口可以枚举用户信息、密码修改、用户创建接口
3、发现登陆后台网址
4、发现在html、JS中泄漏账号密码或者云主机的Access Key和SecretKey
5、自动提取js、html中路径进行访问，也支持自定义父路径访问 ...